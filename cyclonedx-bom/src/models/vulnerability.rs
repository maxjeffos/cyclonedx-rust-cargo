// 1.4 spec: https://cyclonedx.org/docs/1.4/json/
// an example 1.4 sbom with vulnerabilities: https://github.com/CycloneDX/specification/blob/master/tools/src/test/resources/1.4/valid-vulnerability-1.4.json

// TODO: Check out the most official CycloneDX impl (I think that is the C# one) and
// see what fields are optional

use std::convert::TryFrom;

use rust_decimal::Decimal;

#[derive(Debug, PartialEq, Eq)]
pub struct Vulnerabilities(pub Vec<Vulnerability>);

#[derive(Debug, PartialEq, Eq)]
pub struct Vulnerability {
    pub bom_ref: Option<String>, // ser as `bom-ref`
    pub id: Option<String>,
    pub source: Option<VulnSource>,
    pub references: Option<Vec<VulnReference>>, // I guess these are like aliases - other identifiers
    pub ratings: Option<Vec<VulnRating>>,
    pub cwes: Option<Vec<u32>>, // each number must be greater than one - should I use a special type?
    pub description: Option<String>, // maps to OSV summary
    pub detail: Option<String>, // maps to OSV details
    pub recommedation: Option<String>, // spec: Recommendations of how the vulnerability can be remediated or mitigated.
    pub advisories: Option<Vec<VulnAdvisory>>,
    pub created: Option<String>,
    pub published: Option<String>,
    pub updated: Option<String>,
    pub credits: Option<VulnCredit>,
    pub tools: Option<Vec<VulnTool>>,
    pub analysis: Option<VulnAnalysis>,
    pub affects: Option<Vec<VulnAffects>>,
    pub properties: Option<Vec<VulnProperty>>,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnSource {
    pub name: String,
    pub url: String,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnReference {
    pub id: String,
    pub source: VulnSource,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnRating {
    pub source: VulnSource,
    pub score: Decimal, // f32 does not impl Eq. Decimal does - could try using that. Don't know what kind of ser/deser problems I'll run into, though
    pub severity: VulnSeverity,
    pub method: VulnRatingMethod,
    pub vector: String,
    pub justification: String,
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnSeverity {
    Critical, // ser as `critical`
    High,     // ser as `high`
    Medium,   // ser as `medium`
    Low,      // ser as `low`
    Info,     // ser as `info`
    None,     // ser as `none`
    Unknown,  // ser as `unknown`
}

impl ToString for VulnSeverity {
    fn to_string(&self) -> String {
        match self {
            VulnSeverity::Critical => "critical",
            VulnSeverity::High => "high",
            VulnSeverity::Medium => "medium",
            VulnSeverity::Low => "low",
            VulnSeverity::Info => "info",
            VulnSeverity::None => "none",
            VulnSeverity::Unknown => "unknown",
        }
        .to_owned()
    }
}

impl TryFrom<String> for VulnSeverity {
    type Error = String; // TODO: make this a custom error type

    fn try_from(vuln_severity: String) -> Result<Self, Self::Error> {
        match vuln_severity.as_str() {
            "critical" => Ok(Self::Critical),
            "high" => Ok(Self::High),
            "medium" => Ok(Self::Medium),
            "low" => Ok(Self::Low),
            "info" => Ok(Self::Info),
            "none" => Ok(Self::None),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Invalid VulnSeverity: {}", vuln_severity)),
        }
    }
}

impl TryFrom<&str> for VulnSeverity {
    type Error = String; // TODO: make this a custom error type

    fn try_from(vuln_severity: &str) -> Result<Self, Self::Error> {
        match vuln_severity {
            "critical" => Ok(Self::Critical),
            "high" => Ok(Self::High),
            "medium" => Ok(Self::Medium),
            "low" => Ok(Self::Low),
            "info" => Ok(Self::Info),
            "none" => Ok(Self::None),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Invalid VulnSeverity: {}", vuln_severity)),
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnRatingMethod {
    CVSSv2,
    CVSSv3,
    CVSSv31,
    OWASP,
    Other,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnAdvisory {
    pub title: String,
    pub url: String,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnCredit {
    pub organizations: Vec<VulnCreditOrganization>,
    pub individuals: Vec<VulnCreditIndividual>,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnCreditOrganization {
    pub name: String,
    pub url: Vec<String>,
    pub contact: Option<VulnCreditOrganizationContact>,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnCreditOrganizationContact {
    pub name: Option<String>,
    pub email: Option<String>,
    pub phone: Option<String>,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnCreditIndividual {
    pub name: String,
    pub email: Option<String>,
    pub phone: Option<String>,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnTool {
    pub vendor: Option<String>,
    pub name: Option<String>,
    pub version: Option<String>,
    pub hashes: Vec<VulnToolHash>,
    pub external_references: Option<Vec<VulnExternalReference>>, // ser as `externalReferences`
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnToolHash {
    pub alg: VulnToolHashAlgorithm,
    pub content: String,
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnToolHashAlgorithm {
    MD5,        // ser as  `MD5`
    SHA1,       // ser as  `SHA-1`
    SHA256,     // ser as  `SHA-256`
    SHA384,     // ser as  `SHA-384`
    SHA512,     // ser as  `SHA-512`
    SHA3_256,   // ser as  `SHA3-256`
    SHA3_384,   // ser as  `SHA3-384`
    SHA3_512,   // ser as  `SHA3-512`
    BLAKE2b256, // ser as  `BLAKE2b-256`
    BLAKE2b384, // ser as  `BLAKE2b-384`
    BLAKE2b512, // ser as  `BLAKE2b-512`
    BLAKE3,     // ser as  `BLAKE3`
}

pub type VulnExternalReferenceHash = VulnToolHash;

#[derive(Debug, PartialEq, Eq)]
pub struct VulnExternalReference {
    pub url: String,
    pub comment: Option<String>,
    pub ty: VulnExternalReferenceType, // ser as `type`
    pub hashes: Vec<VulnExternalReferenceHash>,
}

#[derive(Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum VulnExternalReferenceType {
    VCS,
    IssueTracker,
    Website,
    Advisories,
    Bom,
    MailingList,
    Social,
    Chat,
    Documentation,
    Support,
    Distribution,
    License,
    BuildMeta,
    BuildSystem,
    ReleaseNotes,
    Other,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnAnalysis {
    pub state: VulnAnalysisState,
    pub justification: VulnAnalysisJustification,
    pub response: Vec<VulnAnalysisResponse>,
    pub detail: String,
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnAnalysisState {
    Resolved,             // ser as "resolved"
    ResolvedWithPedigree, // ser as "resolved_with_pedigree"
    Exploitable,          // ser as "exploitable"
    InTriage,             // ser as "in_triage"
    FalsePositive,        // ser as "false_positive"
    NotAffected,          // ser as "not_affected"
}

#[derive(Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum VulnAnalysisJustification {
    /// the code has been removed or tree-shaked.
    CodeNotPresent,
    /// the vulnerable code is not invoked at runtime.
    CodeNotReachable,
    /// exploitability requires a configurable option to be set/unset.
    RequiresConfiguration,
    /// exploitability requires a dependency that is not present.
    RequiresDependency,
    /// exploitability requires a certain environment which is not present.
    RequiresEnvironment,
    /// exploitability requires a compiler flag to be set/unset.
    ProtectedByCompiler,
    /// exploits are prevented at runtime.
    ProtectedAtRuntime,
    /// attacks are blocked at physical, logical, or network perimeter.
    ProtectedAtPerimeter,
    /// preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability.
    ProtectedByMitigatingControl,
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnAnalysisResponse {
    CanNotFix,
    WillNotFix,
    Update,
    Rollback,
    WorkaroundAvailable,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnAffects {
    pub reference: String, // ser as `ref`
    pub versions: Vec<VulnAffectsVersion>,
}

// TODO: There are two valid options for a VulnAffectsVersion:
//   - the version is required
//   - the range is required
#[derive(Debug, PartialEq, Eq)]
pub struct VulnAffectsVersion {
    pub version: Option<String>,
    pub range: Option<String>,
    pub status: VulnAffectsVersionStatus,
}

#[derive(Debug, PartialEq, Eq)]
pub enum VulnAffectsVersionStatus {
    Affected,
    Unaffected,
    Unknown,
}

#[derive(Debug, PartialEq, Eq)]
pub struct VulnProperty {
    pub name: String,
    pub value: String,
}

use std::convert::TryFrom;

use serde::{Deserialize, Serialize};
// use xml::{reader, writer::XmlEvent};
use rust_decimal::Decimal;

#[allow(unused_imports)]
use crate::{
    // errors::XmlReadError,
    models,
    utilities::{convert_optional, convert_optional_vec, convert_vec},
    xml::{
        attribute_or_error, optional_attribute, read_boolean_tag, read_lax_validation_list_tag,
        read_lax_validation_tag, read_list_tag, read_simple_tag, to_xml_read_error,
        to_xml_write_error, unexpected_element_error, write_simple_tag, FromXml, FromXmlType,
        ToInnerXml, ToXml,
    },
};

#[allow(unused_imports)]
use xml::{reader, writer::XmlEvent};

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct Vulnerabilities(Vec<Vulnerability>);

#[derive(Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Vulnerability {
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<String>,
    pub id: Option<String>,
    pub source: Option<VulnSource>,
    pub references: Option<Vec<VulnReference>>, // I guess these are like aliases - other identifiers
    pub ratings: Option<Vec<VulnRating>>,
    pub cwes: Option<Vec<u32>>, // each number must be greater than one - should I use a special type?
    pub description: Option<String>, // maps to OSV summary
    pub detail: Option<String>, // maps to OSV details
    pub recommedation: Option<String>, // spec: Recommendations of how the vulnerability can be remediated or mitigated.
    pub advisories: Option<Vec<VulnAdvisory>>,
    pub created: Option<String>,
    pub published: Option<String>,
    pub updated: Option<String>,
    pub credits: Option<VulnCredit>,
    pub tools: Option<Vec<VulnTool>>,
    pub analysis: Option<VulnAnalysis>,
    pub affects: Option<Vec<VulnAffects>>,
    pub properties: Option<Vec<VulnProperty>>,
}

impl From<models::vulnerability::Vulnerabilities> for Vulnerabilities {
    fn from(other: models::vulnerability::Vulnerabilities) -> Self {
        Vulnerabilities(convert_vec(other.0))
    }
}

impl From<Vulnerabilities> for models::vulnerability::Vulnerabilities {
    fn from(other: Vulnerabilities) -> Self {
        models::vulnerability::Vulnerabilities(convert_vec(other.0))
    }
}

impl ToInnerXml for Vulnerabilities {
    fn write_xml_named_element<W: std::io::Write>(
        &self,
        writer: &mut xml::EventWriter<W>,
        tag: &str,
    ) -> Result<(), crate::errors::XmlWriteError> {
        writer
            .write(XmlEvent::start_element(tag))
            .map_err(to_xml_write_error(tag))?;

        for vulnerability in &self.0 {
            vulnerability.write_xml_element(writer)?;
        }

        writer
            .write(XmlEvent::end_element())
            .map_err(to_xml_write_error(tag))?;
        Ok(())
    }
}

const VULNERABILITIES_TAG: &str = "vulnerabilities";

impl ToXml for Vulnerabilities {
    fn write_xml_element<W: std::io::Write>(
        &self,
        writer: &mut xml::EventWriter<W>,
    ) -> Result<(), crate::errors::XmlWriteError> {
        self.write_xml_named_element(writer, VULNERABILITIES_TAG)
    }
}

impl FromXml for Vulnerabilities {
    fn read_xml_element<R: std::io::Read>(
        event_reader: &mut xml::EventReader<R>,
        element_name: &xml::name::OwnedName,
        _attributes: &[xml::attribute::OwnedAttribute],
    ) -> Result<Self, crate::errors::XmlReadError>
    where
        Self: Sized,
    {
        read_lax_validation_list_tag(event_reader, element_name, VULNERABILITIES_TAG)
            .map(Vulnerabilities)
    }
}

// TODO: Implement ToXml and FromXml
// for Vulnerabilities, Vulnerability, and all other types.

#[allow(unused_variables)]
impl ToXml for Vulnerability {
    fn write_xml_element<W: std::io::Write>(
        &self,
        writer: &mut xml::EventWriter<W>,
    ) -> Result<(), crate::errors::XmlWriteError> {
        unimplemented!()
    }
}

#[allow(unused_variables)]
impl FromXml for Vulnerability {
    fn read_xml_element<R: std::io::Read>(
        event_reader: &mut xml::EventReader<R>,
        element_name: &xml::name::OwnedName,
        attributes: &[xml::attribute::OwnedAttribute],
    ) -> Result<Self, crate::errors::XmlReadError>
    where
        Self: Sized,
    {
        unimplemented!()
    }
}

impl From<models::vulnerability::Vulnerability> for Vulnerability {
    fn from(other: models::vulnerability::Vulnerability) -> Self {
        Self {
            bom_ref: convert_optional(other.bom_ref),
            id: convert_optional(other.id),
            source: convert_optional(other.source),
            references: convert_optional_vec(other.references),
            ratings: convert_optional_vec(other.ratings),
            cwes: convert_optional_vec(other.cwes),
            description: convert_optional(other.description),
            detail: convert_optional(other.detail),
            recommedation: convert_optional(other.recommedation),
            advisories: convert_optional_vec(other.advisories),
            created: convert_optional(other.created),
            published: convert_optional(other.published),
            updated: convert_optional(other.updated),
            credits: convert_optional(other.credits),
            tools: convert_optional_vec(other.tools),
            analysis: convert_optional(other.analysis),
            affects: convert_optional_vec(other.affects),
            properties: convert_optional_vec(other.properties),
        }
    }
}

impl From<Vulnerability> for models::vulnerability::Vulnerability {
    fn from(other: Vulnerability) -> Self {
        Self {
            bom_ref: convert_optional(other.bom_ref),
            id: convert_optional(other.id),
            source: convert_optional(other.source),
            references: convert_optional_vec(other.references),
            ratings: convert_optional_vec(other.ratings),
            cwes: convert_optional_vec(other.cwes),
            description: convert_optional(other.description),
            detail: convert_optional(other.detail),
            recommedation: convert_optional(other.recommedation),
            advisories: convert_optional_vec(other.advisories),
            created: convert_optional(other.created),
            published: convert_optional(other.published),
            updated: convert_optional(other.updated),
            credits: convert_optional(other.credits),
            tools: convert_optional_vec(other.tools),
            analysis: convert_optional(other.analysis),
            affects: convert_optional_vec(other.affects),
            properties: convert_optional_vec(other.properties),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnSource {
    pub name: String,
    pub url: String,
}

impl From<models::vulnerability::VulnSource> for VulnSource {
    fn from(other: models::vulnerability::VulnSource) -> Self {
        Self {
            name: other.name,
            url: other.url,
        }
    }
}

impl From<VulnSource> for models::vulnerability::VulnSource {
    fn from(other: VulnSource) -> Self {
        Self {
            name: other.name,
            url: other.url,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnReference {
    pub id: String,
    pub source: VulnSource,
}

impl From<models::vulnerability::VulnReference> for VulnReference {
    fn from(other: models::vulnerability::VulnReference) -> Self {
        Self {
            id: other.id,
            source: other.source.into(),
        }
    }
}

impl From<VulnReference> for models::vulnerability::VulnReference {
    fn from(other: VulnReference) -> Self {
        Self {
            id: other.id,
            source: other.source.into(),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnRating {
    pub source: VulnSource,
    pub score: Decimal, // f32 does not impl Eq. Decimal does - could try using that. Don't know what kind of ser/deser problems I'll run into, though
    pub severity: VulnSeverity,
    pub method: VulnRatingMethod,
    pub vector: String,
    pub justification: String,
}

impl From<models::vulnerability::VulnRating> for VulnRating {
    fn from(other: models::vulnerability::VulnRating) -> Self {
        Self {
            source: other.source.into(),
            score: other.score,
            severity: other.severity.into(),
            method: other.method.into(),
            vector: other.vector,
            justification: other.justification,
        }
    }
}

impl From<VulnRating> for models::vulnerability::VulnRating {
    fn from(other: VulnRating) -> Self {
        Self {
            source: other.source.into(),
            score: other.score,
            severity: other.severity.into(),
            method: other.method.into(),
            vector: other.vector,
            justification: other.justification,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum VulnSeverity {
    Critical, // ser as `critical`
    High,     // ser as `high`
    Medium,   // ser as `medium`
    Low,      // ser as `low`
    Info,     // ser as `info`
    None,     // ser as `none`
    Unknown,  // ser as `unknown`
}

impl From<models::vulnerability::VulnSeverity> for VulnSeverity {
    fn from(other: models::vulnerability::VulnSeverity) -> Self {
        match other {
            models::vulnerability::VulnSeverity::Critical => Self::Critical,
            models::vulnerability::VulnSeverity::High => Self::High,
            models::vulnerability::VulnSeverity::Medium => Self::Medium,
            models::vulnerability::VulnSeverity::Low => Self::Low,
            models::vulnerability::VulnSeverity::Info => Self::Info,
            models::vulnerability::VulnSeverity::None => Self::None,
            models::vulnerability::VulnSeverity::Unknown => Self::Unknown,
        }
    }
}

impl From<VulnSeverity> for models::vulnerability::VulnSeverity {
    fn from(other: VulnSeverity) -> Self {
        match other {
            VulnSeverity::Critical => Self::Critical,
            VulnSeverity::High => Self::High,
            VulnSeverity::Medium => Self::Medium,
            VulnSeverity::Low => Self::Low,
            VulnSeverity::Info => Self::Info,
            VulnSeverity::None => Self::None,
            VulnSeverity::Unknown => Self::Unknown,
        }
    }
}

impl ToString for VulnSeverity {
    fn to_string(&self) -> String {
        match self {
            VulnSeverity::Critical => "critical",
            VulnSeverity::High => "high",
            VulnSeverity::Medium => "medium",
            VulnSeverity::Low => "low",
            VulnSeverity::Info => "info",
            VulnSeverity::None => "none",
            VulnSeverity::Unknown => "unknown",
        }
        .to_owned()
    }
}

impl TryFrom<String> for VulnSeverity {
    type Error = String; // TODO: make this a custom error type

    fn try_from(vuln_severity: String) -> Result<Self, Self::Error> {
        match vuln_severity.as_str() {
            "critical" => Ok(Self::Critical),
            "high" => Ok(Self::High),
            "medium" => Ok(Self::Medium),
            "low" => Ok(Self::Low),
            "info" => Ok(Self::Info),
            "none" => Ok(Self::None),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Invalid VulnSeverity: {}", vuln_severity)),
        }
    }
}

impl TryFrom<&str> for VulnSeverity {
    type Error = String; // TODO: make this a custom error type

    fn try_from(vuln_severity: &str) -> Result<Self, Self::Error> {
        match vuln_severity {
            "critical" => Ok(Self::Critical),
            "high" => Ok(Self::High),
            "medium" => Ok(Self::Medium),
            "low" => Ok(Self::Low),
            "info" => Ok(Self::Info),
            "none" => Ok(Self::None),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Invalid VulnSeverity: {}", vuln_severity)),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
// TODO: serde rename
pub enum VulnRatingMethod {
    CVSSv2,
    CVSSv3,
    CVSSv31,
    OWASP,
    #[serde(rename = "other")]
    Other,
}

impl From<models::vulnerability::VulnRatingMethod> for VulnRatingMethod {
    fn from(other: models::vulnerability::VulnRatingMethod) -> Self {
        match other {
            models::vulnerability::VulnRatingMethod::CVSSv2 => Self::CVSSv2,
            models::vulnerability::VulnRatingMethod::CVSSv3 => Self::CVSSv3,
            models::vulnerability::VulnRatingMethod::CVSSv31 => Self::CVSSv31,
            models::vulnerability::VulnRatingMethod::OWASP => Self::OWASP,
            models::vulnerability::VulnRatingMethod::Other => Self::Other,
        }
    }
}

impl From<VulnRatingMethod> for models::vulnerability::VulnRatingMethod {
    fn from(other: VulnRatingMethod) -> Self {
        match other {
            VulnRatingMethod::CVSSv2 => Self::CVSSv2,
            VulnRatingMethod::CVSSv3 => Self::CVSSv3,
            VulnRatingMethod::CVSSv31 => Self::CVSSv31,
            VulnRatingMethod::OWASP => Self::OWASP,
            VulnRatingMethod::Other => Self::Other,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnAdvisory {
    pub title: String,
    pub url: String,
}

impl From<models::vulnerability::VulnAdvisory> for VulnAdvisory {
    fn from(other: models::vulnerability::VulnAdvisory) -> Self {
        Self {
            title: other.title,
            url: other.url,
        }
    }
}

impl From<VulnAdvisory> for models::vulnerability::VulnAdvisory {
    fn from(other: VulnAdvisory) -> Self {
        Self {
            title: other.title,
            url: other.url,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnCredit {
    pub organizations: Vec<VulnCreditOrganization>,
    pub individuals: Vec<VulnCreditIndividual>,
}

impl From<models::vulnerability::VulnCredit> for VulnCredit {
    fn from(other: models::vulnerability::VulnCredit) -> Self {
        Self {
            organizations: other
                .organizations
                .into_iter()
                .map(VulnCreditOrganization::from)
                .collect(),
            individuals: other
                .individuals
                .into_iter()
                .map(VulnCreditIndividual::from)
                .collect(),
        }
    }
}

impl From<VulnCredit> for models::vulnerability::VulnCredit {
    fn from(other: VulnCredit) -> Self {
        Self {
            organizations: other
                .organizations
                .into_iter()
                .map(models::vulnerability::VulnCreditOrganization::from)
                .collect(),
            individuals: other
                .individuals
                .into_iter()
                .map(models::vulnerability::VulnCreditIndividual::from)
                .collect(),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnCreditOrganization {
    pub name: String,
    pub url: Vec<String>,
    pub contact: Option<VulnCreditOrganizationContact>,
}

impl From<models::vulnerability::VulnCreditOrganization> for VulnCreditOrganization {
    fn from(other: models::vulnerability::VulnCreditOrganization) -> Self {
        Self {
            name: other.name,
            url: other.url,
            contact: other.contact.map(VulnCreditOrganizationContact::from),
        }
    }
}

impl From<VulnCreditOrganization> for models::vulnerability::VulnCreditOrganization {
    fn from(other: VulnCreditOrganization) -> Self {
        Self {
            name: other.name,
            url: other.url,
            contact: other
                .contact
                .map(models::vulnerability::VulnCreditOrganizationContact::from),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnCreditOrganizationContact {
    pub name: Option<String>,
    pub email: Option<String>,
    pub phone: Option<String>,
}

impl From<models::vulnerability::VulnCreditOrganizationContact> for VulnCreditOrganizationContact {
    fn from(other: models::vulnerability::VulnCreditOrganizationContact) -> Self {
        Self {
            name: other.name,
            email: other.email,
            phone: other.phone,
        }
    }
}

impl From<VulnCreditOrganizationContact> for models::vulnerability::VulnCreditOrganizationContact {
    fn from(other: VulnCreditOrganizationContact) -> Self {
        Self {
            name: other.name,
            email: other.email,
            phone: other.phone,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnCreditIndividual {
    pub name: String,
    pub email: Option<String>,
    pub phone: Option<String>,
}

impl From<models::vulnerability::VulnCreditIndividual> for VulnCreditIndividual {
    fn from(other: models::vulnerability::VulnCreditIndividual) -> Self {
        Self {
            name: other.name,
            email: other.email,
            phone: other.phone,
        }
    }
}

impl From<VulnCreditIndividual> for models::vulnerability::VulnCreditIndividual {
    fn from(other: VulnCreditIndividual) -> Self {
        Self {
            name: other.name,
            email: other.email,
            phone: other.phone,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnTool {
    pub vendor: Option<String>,
    pub name: Option<String>,
    pub version: Option<String>,
    pub hashes: Vec<VulnToolHash>,
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<VulnExternalReference>>,
}

impl From<models::vulnerability::VulnTool> for VulnTool {
    fn from(other: models::vulnerability::VulnTool) -> Self {
        Self {
            vendor: other.vendor,
            name: other.name,
            version: other.version,
            hashes: other.hashes.into_iter().map(VulnToolHash::from).collect(),
            external_references: other
                .external_references
                .map(|v| v.into_iter().map(VulnExternalReference::from).collect()),
        }
    }
}

impl From<VulnTool> for models::vulnerability::VulnTool {
    fn from(other: VulnTool) -> Self {
        Self {
            vendor: other.vendor,
            name: other.name,
            version: other.version,
            hashes: other
                .hashes
                .into_iter()
                .map(models::vulnerability::VulnToolHash::from)
                .collect(),
            external_references: other.external_references.map(|v| {
                v.into_iter()
                    .map(models::vulnerability::VulnExternalReference::from)
                    .collect()
            }),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnToolHash {
    pub alg: VulnToolHashAlgorithm,
    pub content: String,
}

impl From<models::vulnerability::VulnToolHash> for VulnToolHash {
    fn from(other: models::vulnerability::VulnToolHash) -> Self {
        Self {
            alg: other.alg.into(),
            content: other.content,
        }
    }
}

impl From<VulnToolHash> for models::vulnerability::VulnToolHash {
    fn from(other: VulnToolHash) -> Self {
        Self {
            alg: other.alg.into(),
            content: other.content,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub enum VulnToolHashAlgorithm {
    MD5, // ser as  `MD5`
    #[serde(rename = "SHA-1")]
    SHA1, // ser as  `SHA-1`
    #[serde(rename = "SHA-256")]
    SHA256, // ser as  `SHA-256`
    #[serde(rename = "SHA-384")]
    SHA384, // ser as  `SHA-384`
    #[serde(rename = "SHA-512")]
    SHA512, // ser as  `SHA-512`
    #[serde(rename = "SHA3-256")]
    SHA3_256, // ser as  `SHA3-256`
    #[serde(rename = "SHA3-384")]
    SHA3_384, // ser as  `SHA3-384`
    #[serde(rename = "SHA3-512")]
    SHA3_512, // ser as  `SHA3-512`
    #[serde(rename = "BLAKE2b-256")]
    BLAKE2b256, // ser as  `BLAKE2b-256`
    #[serde(rename = "BLAKE2b-384")]
    BLAKE2b384, // ser as  `BLAKE2b-384`
    #[serde(rename = "BLAKE2b-512")]
    BLAKE2b512, // ser as  `BLAKE2b-512`
    BLAKE3, // ser as  `BLAKE3`
}

impl From<models::vulnerability::VulnToolHashAlgorithm> for VulnToolHashAlgorithm {
    fn from(other: models::vulnerability::VulnToolHashAlgorithm) -> Self {
        match other {
            models::vulnerability::VulnToolHashAlgorithm::MD5 => VulnToolHashAlgorithm::MD5,
            models::vulnerability::VulnToolHashAlgorithm::SHA1 => VulnToolHashAlgorithm::SHA1,
            models::vulnerability::VulnToolHashAlgorithm::SHA256 => VulnToolHashAlgorithm::SHA256,
            models::vulnerability::VulnToolHashAlgorithm::SHA384 => VulnToolHashAlgorithm::SHA384,
            models::vulnerability::VulnToolHashAlgorithm::SHA512 => VulnToolHashAlgorithm::SHA512,
            models::vulnerability::VulnToolHashAlgorithm::SHA3_256 => {
                VulnToolHashAlgorithm::SHA3_256
            }
            models::vulnerability::VulnToolHashAlgorithm::SHA3_384 => {
                VulnToolHashAlgorithm::SHA3_384
            }
            models::vulnerability::VulnToolHashAlgorithm::SHA3_512 => {
                VulnToolHashAlgorithm::SHA3_512
            }
            models::vulnerability::VulnToolHashAlgorithm::BLAKE2b256 => {
                VulnToolHashAlgorithm::BLAKE2b256
            }
            models::vulnerability::VulnToolHashAlgorithm::BLAKE2b384 => {
                VulnToolHashAlgorithm::BLAKE2b384
            }
            models::vulnerability::VulnToolHashAlgorithm::BLAKE2b512 => {
                VulnToolHashAlgorithm::BLAKE2b512
            }
            models::vulnerability::VulnToolHashAlgorithm::BLAKE3 => VulnToolHashAlgorithm::BLAKE3,
        }
    }
}

impl From<VulnToolHashAlgorithm> for models::vulnerability::VulnToolHashAlgorithm {
    fn from(other: VulnToolHashAlgorithm) -> Self {
        match other {
            VulnToolHashAlgorithm::MD5 => models::vulnerability::VulnToolHashAlgorithm::MD5,
            VulnToolHashAlgorithm::SHA1 => models::vulnerability::VulnToolHashAlgorithm::SHA1,
            VulnToolHashAlgorithm::SHA256 => models::vulnerability::VulnToolHashAlgorithm::SHA256,
            VulnToolHashAlgorithm::SHA384 => models::vulnerability::VulnToolHashAlgorithm::SHA384,
            VulnToolHashAlgorithm::SHA512 => models::vulnerability::VulnToolHashAlgorithm::SHA512,
            VulnToolHashAlgorithm::SHA3_256 => {
                models::vulnerability::VulnToolHashAlgorithm::SHA3_256
            }
            VulnToolHashAlgorithm::SHA3_384 => {
                models::vulnerability::VulnToolHashAlgorithm::SHA3_384
            }
            VulnToolHashAlgorithm::SHA3_512 => {
                models::vulnerability::VulnToolHashAlgorithm::SHA3_512
            }
            VulnToolHashAlgorithm::BLAKE2b256 => {
                models::vulnerability::VulnToolHashAlgorithm::BLAKE2b256
            }
            VulnToolHashAlgorithm::BLAKE2b384 => {
                models::vulnerability::VulnToolHashAlgorithm::BLAKE2b384
            }
            VulnToolHashAlgorithm::BLAKE2b512 => {
                models::vulnerability::VulnToolHashAlgorithm::BLAKE2b512
            }
            VulnToolHashAlgorithm::BLAKE3 => models::vulnerability::VulnToolHashAlgorithm::BLAKE3,
        }
    }
}

pub type VulnExternalReferenceHash = VulnToolHash;

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnExternalReference {
    pub url: String,
    pub comment: Option<String>,

    #[serde(rename = "type")]
    pub ty: VulnExternalReferenceType, // ser as `type`
    pub hashes: Vec<VulnExternalReferenceHash>,
}

impl From<models::vulnerability::VulnExternalReference> for VulnExternalReference {
    fn from(other: models::vulnerability::VulnExternalReference) -> Self {
        VulnExternalReference {
            url: other.url,
            comment: other.comment,
            ty: other.ty.into(),
            hashes: other.hashes.into_iter().map(|x| x.into()).collect(),
        }
    }
}

impl From<VulnExternalReference> for models::vulnerability::VulnExternalReference {
    fn from(other: VulnExternalReference) -> Self {
        models::vulnerability::VulnExternalReference {
            url: other.url,
            comment: other.comment,
            ty: other.ty.into(),
            hashes: other.hashes.into_iter().map(|x| x.into()).collect(),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
#[allow(non_camel_case_types)]
pub enum VulnExternalReferenceType {
    #[serde(rename = "vcs")]
    VCS,
    #[serde(rename = "issue-tracker")]
    IssueTracker,
    #[serde(rename = "website")]
    Website,
    #[serde(rename = "advisories")]
    Advisories,
    #[serde(rename = "bom")]
    Bom,
    #[serde(rename = "mailing-list")]
    MailingList,
    #[serde(rename = "social")]
    Social,
    #[serde(rename = "chat")]
    Chat,
    #[serde(rename = "documentation")]
    Documentation,
    #[serde(rename = "support")]
    Support,
    #[serde(rename = "distribution")]
    Distribution,
    #[serde(rename = "license")]
    License,
    #[serde(rename = "build-meta")]
    BuildMeta,
    #[serde(rename = "build-system")]
    BuildSystem,
    #[serde(rename = "release-notes")]
    ReleaseNotes,
    #[serde(rename = "other")]
    Other,
}

impl From<models::vulnerability::VulnExternalReferenceType> for VulnExternalReferenceType {
    fn from(other: models::vulnerability::VulnExternalReferenceType) -> Self {
        match other {
            models::vulnerability::VulnExternalReferenceType::VCS => VulnExternalReferenceType::VCS,
            models::vulnerability::VulnExternalReferenceType::IssueTracker => {
                VulnExternalReferenceType::IssueTracker
            }
            models::vulnerability::VulnExternalReferenceType::Website => {
                VulnExternalReferenceType::Website
            }
            models::vulnerability::VulnExternalReferenceType::Advisories => {
                VulnExternalReferenceType::Advisories
            }
            models::vulnerability::VulnExternalReferenceType::Bom => VulnExternalReferenceType::Bom,
            models::vulnerability::VulnExternalReferenceType::MailingList => {
                VulnExternalReferenceType::MailingList
            }
            models::vulnerability::VulnExternalReferenceType::Social => {
                VulnExternalReferenceType::Social
            }
            models::vulnerability::VulnExternalReferenceType::Chat => {
                VulnExternalReferenceType::Chat
            }
            models::vulnerability::VulnExternalReferenceType::Documentation => {
                VulnExternalReferenceType::Documentation
            }
            models::vulnerability::VulnExternalReferenceType::Support => {
                VulnExternalReferenceType::Support
            }
            models::vulnerability::VulnExternalReferenceType::Distribution => {
                VulnExternalReferenceType::Distribution
            }
            models::vulnerability::VulnExternalReferenceType::License => {
                VulnExternalReferenceType::License
            }
            models::vulnerability::VulnExternalReferenceType::BuildMeta => {
                VulnExternalReferenceType::BuildMeta
            }
            models::vulnerability::VulnExternalReferenceType::BuildSystem => {
                VulnExternalReferenceType::BuildSystem
            }
            models::vulnerability::VulnExternalReferenceType::ReleaseNotes => {
                VulnExternalReferenceType::ReleaseNotes
            }
            models::vulnerability::VulnExternalReferenceType::Other => {
                VulnExternalReferenceType::Other
            }
        }
    }
}

impl From<VulnExternalReferenceType> for models::vulnerability::VulnExternalReferenceType {
    fn from(other: VulnExternalReferenceType) -> Self {
        match other {
            VulnExternalReferenceType::VCS => models::vulnerability::VulnExternalReferenceType::VCS,
            VulnExternalReferenceType::IssueTracker => {
                models::vulnerability::VulnExternalReferenceType::IssueTracker
            }
            VulnExternalReferenceType::Website => {
                models::vulnerability::VulnExternalReferenceType::Website
            }
            VulnExternalReferenceType::Advisories => {
                models::vulnerability::VulnExternalReferenceType::Advisories
            }
            VulnExternalReferenceType::Bom => models::vulnerability::VulnExternalReferenceType::Bom,
            VulnExternalReferenceType::MailingList => {
                models::vulnerability::VulnExternalReferenceType::MailingList
            }
            VulnExternalReferenceType::Social => {
                models::vulnerability::VulnExternalReferenceType::Social
            }
            VulnExternalReferenceType::Chat => {
                models::vulnerability::VulnExternalReferenceType::Chat
            }
            VulnExternalReferenceType::Documentation => {
                models::vulnerability::VulnExternalReferenceType::Documentation
            }
            VulnExternalReferenceType::Support => {
                models::vulnerability::VulnExternalReferenceType::Support
            }
            VulnExternalReferenceType::Distribution => {
                models::vulnerability::VulnExternalReferenceType::Distribution
            }
            VulnExternalReferenceType::License => {
                models::vulnerability::VulnExternalReferenceType::License
            }
            VulnExternalReferenceType::BuildMeta => {
                models::vulnerability::VulnExternalReferenceType::BuildMeta
            }
            VulnExternalReferenceType::BuildSystem => {
                models::vulnerability::VulnExternalReferenceType::BuildSystem
            }
            VulnExternalReferenceType::ReleaseNotes => {
                models::vulnerability::VulnExternalReferenceType::ReleaseNotes
            }
            VulnExternalReferenceType::Other => {
                models::vulnerability::VulnExternalReferenceType::Other
            }
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnAnalysis {
    pub state: VulnAnalysisState,
    pub justification: VulnAnalysisJustification,
    pub response: Vec<VulnAnalysisResponse>,
    pub detail: String,
}

impl From<models::vulnerability::VulnAnalysis> for VulnAnalysis {
    fn from(other: models::vulnerability::VulnAnalysis) -> Self {
        VulnAnalysis {
            state: other.state.into(),
            justification: other.justification.into(),
            response: other.response.into_iter().map(|r| r.into()).collect(),
            detail: other.detail,
        }
    }
}

impl From<VulnAnalysis> for models::vulnerability::VulnAnalysis {
    fn from(other: VulnAnalysis) -> Self {
        models::vulnerability::VulnAnalysis {
            state: other.state.into(),
            justification: other.justification.into(),
            response: other.response.into_iter().map(|r| r.into()).collect(),
            detail: other.detail,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub enum VulnAnalysisState {
    #[serde(rename = "resolved")]
    Resolved, // ser as "resolved"
    #[serde(rename = "resolved_with_pedigree")]
    ResolvedWithPedigree, // ser as "resolved_with_pedigree"
    #[serde(rename = "exploitable")]
    Exploitable, // ser as "exploitable"
    #[serde(rename = "in_triage")]
    InTriage, // ser as "in_triage"
    #[serde(rename = "false_positive")]
    FalsePositive, // ser as "false_positive"
    #[serde(rename = "not_affected")]
    NotAffected, // ser as "not_affected"
}

impl From<models::vulnerability::VulnAnalysisState> for VulnAnalysisState {
    fn from(other: models::vulnerability::VulnAnalysisState) -> Self {
        match other {
            models::vulnerability::VulnAnalysisState::Resolved => VulnAnalysisState::Resolved,
            models::vulnerability::VulnAnalysisState::ResolvedWithPedigree => {
                VulnAnalysisState::ResolvedWithPedigree
            }
            models::vulnerability::VulnAnalysisState::Exploitable => VulnAnalysisState::Exploitable,
            models::vulnerability::VulnAnalysisState::InTriage => VulnAnalysisState::InTriage,
            models::vulnerability::VulnAnalysisState::FalsePositive => {
                VulnAnalysisState::FalsePositive
            }
            models::vulnerability::VulnAnalysisState::NotAffected => VulnAnalysisState::NotAffected,
        }
    }
}

impl From<VulnAnalysisState> for models::vulnerability::VulnAnalysisState {
    fn from(other: VulnAnalysisState) -> Self {
        match other {
            VulnAnalysisState::Resolved => models::vulnerability::VulnAnalysisState::Resolved,
            VulnAnalysisState::ResolvedWithPedigree => {
                models::vulnerability::VulnAnalysisState::ResolvedWithPedigree
            }
            VulnAnalysisState::Exploitable => models::vulnerability::VulnAnalysisState::Exploitable,
            VulnAnalysisState::InTriage => models::vulnerability::VulnAnalysisState::InTriage,
            VulnAnalysisState::FalsePositive => {
                models::vulnerability::VulnAnalysisState::FalsePositive
            }
            VulnAnalysisState::NotAffected => models::vulnerability::VulnAnalysisState::NotAffected,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
#[allow(non_camel_case_types)]
pub enum VulnAnalysisJustification {
    #[serde(rename = "code_not_present")]
    CodeNotPresent, // ser as `code_not_present` = the code has been removed or tree-shaked.

    #[serde(rename = "code_not_reachable")]
    CodeNotReachable, // ser as `code_not_reachable` = the vulnerable code is not invoked at runtime.

    #[serde(rename = "requires_configuration")]
    RequiresConfiguration, // ser as `requires_configuration` = exploitability requires a configurable option to be set/unset.

    #[serde(rename = "requires_dependency")]
    RequiresDependency, // ser as `requires_dependency` = exploitability requires a dependency that is not present.

    #[serde(rename = "requires_environment")]
    RequiresEnvironment, // ser as `requires_environment` = exploitability requires a certain environment which is not present.

    #[serde(rename = "protected_by_compiler")]
    ProtectedByCompiler, // ser as `protected_by_compiler` = exploitability requires a compiler flag to be set/unset.

    #[serde(rename = "protected_at_runtime")]
    ProtectedAtRuntime, // ser as `protected_at_runtime` = exploits are prevented at runtime.

    #[serde(rename = "protected_at_perimeter")]
    ProtectedAtPerimeter, // ser as `protected_at_perimeter` = attacks are blocked at physical, logical, or network perimeter.

    #[serde(rename = "protected_by_mitigating_control")]
    ProtectedByMitigatingControl, // ser as `protected_by_mitigating_control` = preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability.
}

impl From<models::vulnerability::VulnAnalysisJustification> for VulnAnalysisJustification {
    fn from(vuln_analysis_justification: models::vulnerability::VulnAnalysisJustification) -> Self {
        match vuln_analysis_justification {
            models::vulnerability::VulnAnalysisJustification::CodeNotPresent => {
                VulnAnalysisJustification::CodeNotPresent
            }
            models::vulnerability::VulnAnalysisJustification::CodeNotReachable => {
                VulnAnalysisJustification::CodeNotReachable
            }
            models::vulnerability::VulnAnalysisJustification::RequiresConfiguration => {
                VulnAnalysisJustification::RequiresConfiguration
            }
            models::vulnerability::VulnAnalysisJustification::RequiresDependency => {
                VulnAnalysisJustification::RequiresDependency
            }
            models::vulnerability::VulnAnalysisJustification::RequiresEnvironment => {
                VulnAnalysisJustification::RequiresEnvironment
            }
            models::vulnerability::VulnAnalysisJustification::ProtectedByCompiler => {
                VulnAnalysisJustification::ProtectedByCompiler
            }
            models::vulnerability::VulnAnalysisJustification::ProtectedAtRuntime => {
                VulnAnalysisJustification::ProtectedAtRuntime
            }
            models::vulnerability::VulnAnalysisJustification::ProtectedAtPerimeter => {
                VulnAnalysisJustification::ProtectedAtPerimeter
            }
            models::vulnerability::VulnAnalysisJustification::ProtectedByMitigatingControl => {
                VulnAnalysisJustification::ProtectedByMitigatingControl
            }
        }
    }
}

impl From<VulnAnalysisJustification> for models::vulnerability::VulnAnalysisJustification {
    fn from(vuln_analysis_justification: VulnAnalysisJustification) -> Self {
        match vuln_analysis_justification {
            VulnAnalysisJustification::CodeNotPresent => {
                models::vulnerability::VulnAnalysisJustification::CodeNotPresent
            }
            VulnAnalysisJustification::CodeNotReachable => {
                models::vulnerability::VulnAnalysisJustification::CodeNotReachable
            }
            VulnAnalysisJustification::RequiresConfiguration => {
                models::vulnerability::VulnAnalysisJustification::RequiresConfiguration
            }
            VulnAnalysisJustification::RequiresDependency => {
                models::vulnerability::VulnAnalysisJustification::RequiresDependency
            }
            VulnAnalysisJustification::RequiresEnvironment => {
                models::vulnerability::VulnAnalysisJustification::RequiresEnvironment
            }
            VulnAnalysisJustification::ProtectedByCompiler => {
                models::vulnerability::VulnAnalysisJustification::ProtectedByCompiler
            }
            VulnAnalysisJustification::ProtectedAtRuntime => {
                models::vulnerability::VulnAnalysisJustification::ProtectedAtRuntime
            }
            VulnAnalysisJustification::ProtectedAtPerimeter => {
                models::vulnerability::VulnAnalysisJustification::ProtectedAtPerimeter
            }
            VulnAnalysisJustification::ProtectedByMitigatingControl => {
                models::vulnerability::VulnAnalysisJustification::ProtectedByMitigatingControl
            }
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub enum VulnAnalysisResponse {
    #[serde(rename = "can_not_fix")]
    CanNotFix,
    #[serde(rename = "will_not_fix")]
    WillNotFix,
    #[serde(rename = "update")]
    Update,
    #[serde(rename = "rollback")]
    Rollback,
    #[serde(rename = "workaround_available")]
    WorkaroundAvailable,
}

impl From<models::vulnerability::VulnAnalysisResponse> for VulnAnalysisResponse {
    fn from(vuln_analysis_response: models::vulnerability::VulnAnalysisResponse) -> Self {
        match vuln_analysis_response {
            models::vulnerability::VulnAnalysisResponse::CanNotFix => {
                VulnAnalysisResponse::CanNotFix
            }
            models::vulnerability::VulnAnalysisResponse::WillNotFix => {
                VulnAnalysisResponse::WillNotFix
            }
            models::vulnerability::VulnAnalysisResponse::Update => VulnAnalysisResponse::Update,
            models::vulnerability::VulnAnalysisResponse::Rollback => VulnAnalysisResponse::Rollback,
            models::vulnerability::VulnAnalysisResponse::WorkaroundAvailable => {
                VulnAnalysisResponse::WorkaroundAvailable
            }
        }
    }
}

impl From<VulnAnalysisResponse> for models::vulnerability::VulnAnalysisResponse {
    fn from(vuln_analysis_response: VulnAnalysisResponse) -> Self {
        match vuln_analysis_response {
            VulnAnalysisResponse::CanNotFix => {
                models::vulnerability::VulnAnalysisResponse::CanNotFix
            }
            VulnAnalysisResponse::WillNotFix => {
                models::vulnerability::VulnAnalysisResponse::WillNotFix
            }
            VulnAnalysisResponse::Update => models::vulnerability::VulnAnalysisResponse::Update,
            VulnAnalysisResponse::Rollback => models::vulnerability::VulnAnalysisResponse::Rollback,
            VulnAnalysisResponse::WorkaroundAvailable => {
                models::vulnerability::VulnAnalysisResponse::WorkaroundAvailable
            }
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnAffects {
    #[serde(rename = "ref")]
    pub reference: String,
    pub versions: Vec<VulnAffectsVersion>,
}

impl From<models::vulnerability::VulnAffects> for VulnAffects {
    fn from(vuln_affects: models::vulnerability::VulnAffects) -> Self {
        VulnAffects {
            reference: vuln_affects.reference,
            versions: vuln_affects
                .versions
                .into_iter()
                .map(|v| VulnAffectsVersion::from(v))
                .collect(),
        }
    }
}

impl From<VulnAffects> for models::vulnerability::VulnAffects {
    fn from(vuln_affects: VulnAffects) -> Self {
        models::vulnerability::VulnAffects {
            reference: vuln_affects.reference,
            versions: vuln_affects
                .versions
                .into_iter()
                .map(|v| models::vulnerability::VulnAffectsVersion::from(v))
                .collect(),
        }
    }
}

// TODO: There are two valid options for a VulnAffectsVersion:
//   - the version is required
//   - the range is required
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnAffectsVersion {
    pub version: Option<String>,
    pub range: Option<String>,
    pub status: VulnAffectsVersionStatus,
}

impl From<models::vulnerability::VulnAffectsVersion> for VulnAffectsVersion {
    fn from(vuln_affects_version: models::vulnerability::VulnAffectsVersion) -> Self {
        VulnAffectsVersion {
            version: vuln_affects_version.version,
            range: vuln_affects_version.range,
            status: VulnAffectsVersionStatus::from(vuln_affects_version.status),
        }
    }
}

impl From<VulnAffectsVersion> for models::vulnerability::VulnAffectsVersion {
    fn from(vuln_affects_version: VulnAffectsVersion) -> Self {
        models::vulnerability::VulnAffectsVersion {
            version: vuln_affects_version.version,
            range: vuln_affects_version.range,
            status: models::vulnerability::VulnAffectsVersionStatus::from(
                vuln_affects_version.status,
            ),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum VulnAffectsVersionStatus {
    Affected,
    Unaffected,
    Unknown,
}

impl From<models::vulnerability::VulnAffectsVersionStatus> for VulnAffectsVersionStatus {
    fn from(vuln_affects_version_status: models::vulnerability::VulnAffectsVersionStatus) -> Self {
        match vuln_affects_version_status {
            models::vulnerability::VulnAffectsVersionStatus::Affected => {
                VulnAffectsVersionStatus::Affected
            }
            models::vulnerability::VulnAffectsVersionStatus::Unaffected => {
                VulnAffectsVersionStatus::Unaffected
            }
            models::vulnerability::VulnAffectsVersionStatus::Unknown => {
                VulnAffectsVersionStatus::Unknown
            }
        }
    }
}

impl From<VulnAffectsVersionStatus> for models::vulnerability::VulnAffectsVersionStatus {
    fn from(vuln_affects_version_status: VulnAffectsVersionStatus) -> Self {
        match vuln_affects_version_status {
            VulnAffectsVersionStatus::Affected => {
                models::vulnerability::VulnAffectsVersionStatus::Affected
            }
            VulnAffectsVersionStatus::Unaffected => {
                models::vulnerability::VulnAffectsVersionStatus::Unaffected
            }
            VulnAffectsVersionStatus::Unknown => {
                models::vulnerability::VulnAffectsVersionStatus::Unknown
            }
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VulnProperty {
    pub name: String,
    pub value: String,
}

impl From<models::vulnerability::VulnProperty> for VulnProperty {
    fn from(vuln_property: models::vulnerability::VulnProperty) -> Self {
        VulnProperty {
            name: vuln_property.name,
            value: vuln_property.value,
        }
    }
}

impl From<VulnProperty> for models::vulnerability::VulnProperty {
    fn from(vuln_property: VulnProperty) -> Self {
        models::vulnerability::VulnProperty {
            name: vuln_property.name,
            value: vuln_property.value,
        }
    }
}
